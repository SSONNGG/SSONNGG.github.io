{"title":"Eureka相关理论","uid":"16e16a971c2690fe161fa7eece5339e5","slug":"Eureka相关理论","date":"2020-10-25T09:32:51.000Z","updated":"2020-11-02T12:28:02.000Z","comments":true,"path":"api/articles/Eureka相关理论.json","keywords":null,"cover":[],"content":"<h1 id=\"一、EureKa核心概念\"><a href=\"#一、EureKa核心概念\" class=\"headerlink\" title=\"一、EureKa核心概念\"></a>一、EureKa核心概念</h1><p>Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是<strong>服务注册中心</strong>。</p>\n<p>整体上可以分为两个主体：<strong>Eureka Server</strong> 和 <strong>Eureka Client</strong>. Service provider(服务提供者：负责服务注册和续约的操作) 和 Service consumer(服务消费者：负责获取服务注册的信息) 本质都是Eureka Client.</p>\n<p>EureKa 保证了 CAP 中的 AP（即可用性和分区容忍性）</p>\n<p>EureKa中注册信息和服务器上的信息保证了最终一致性（即服务器宕掉之后仍旧能使用，上线后再次进行同步。不考虑中间不一致）</p>\n<h2 id=\"Eureka-Server：注册中心服务端\"><a href=\"#Eureka-Server：注册中心服务端\" class=\"headerlink\" title=\"Eureka Server：注册中心服务端\"></a>Eureka Server：注册中心服务端</h2><ol>\n<li><p><strong>服务注册:</strong> </p>\n<p>服务提供者启动时，会通过 Eureka Client 向 Eureka Server 发送 <strong>REST请求</strong> 的方式向 Eureka Server 注册自己的服务信息数据，这些数据是服务自身的元数据，比如<strong>ip地址、端口、运行状况指标的url、主页地址</strong>等信息, Eureka Server 会存储该服务的信息，Eureka Server 内部有二层缓存机制 (一个双层的Map) 中来维护整个注册表。</p>\n<p><img src=\"Eureka%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/image-20201025184510868.png\" alt=\"EureKa 二层缓存机制解释\"></p>\n</li>\n<li><p><strong>提供注册表:</strong> </p>\n<p>服务消费者在调用服务时，如果 Eureka Client 没有缓存注册表的话，会从 Eureka Server 获取最新的注册表。</p>\n</li>\n<li><p><strong>同步状态:</strong> </p>\n<p>Eureka Client 通过注册、心跳机制和 Eureka Server 同步当前客户端的状态。</p>\n</li>\n<li><p><strong>Eviction 服务剔除：</strong></p>\n<p>当 Eureka Client 和 Eureka Server <strong>不再有心跳时</strong>，Eureka Server 会将该服务实例从服务注册列表中删除，即服务剔除。</p>\n</li>\n</ol>\n<h2 id=\"Eureka-Client：注册中心客户端\"><a href=\"#Eureka-Client：注册中心客户端\" class=\"headerlink\" title=\"Eureka Client：注册中心客户端\"></a>Eureka Client：注册中心客户端</h2><p>&emsp;&emsp;它是一个 Java 客户端，用于简化与 Eureka Server 的交互。Eureka Client 会<span style=\"color:red\"><strong>拉取、更新和缓存</strong></span>Eureka Server 中的信息。因此<span style=\"color:red\">当所有的 Eureka Server 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致. </span>(分布式集群最重要的问题：如何保持数据的一致性？EureKa满足最终一致，因为 EureKa 需要保持 CAP 中的 AP )</p>\n<ol>\n<li><p><strong>Register:  服务注册</strong></p>\n<p>服务的提供者, 将自身注册到注册中心，服务提供者也是一个 Eureka Client。</p>\n</li>\n<li><p><strong>Renew:  服务续约</strong></p>\n<p>&emsp;&emsp;Eureka Client 会每隔 30 秒发送一次心跳来续约。 <strong>通过续约来告知 Eureka Server 该 Eureka Client 运行正常，没有出现问题。</strong> 默认情况下，如果 Eureka Server 在 90 秒内没有收到 Eureka Client 的续约，Server 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。</p>\n<p>有关修改服务续约调用时间的属性（可在application.yml中修改）：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># 服务续约任务的调用间隔时间，默认为30秒</span>\neureka.instance.lease<span class=\"token punctuation\">-</span>renewal<span class=\"token punctuation\">-</span>interval<span class=\"token punctuation\">-</span>in<span class=\"token punctuation\">-</span>seconds=30\n<span class=\"token comment\"># 服务失效的时间，默认为90秒。</span>\neureka.instance.lease<span class=\"token punctuation\">-</span>expiration<span class=\"token punctuation\">-</span>duration<span class=\"token punctuation\">-</span>in<span class=\"token punctuation\">-</span>seconds=90<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p><strong>Cancel:  服务下线</strong> </p>\n<p>&emsp;&emsp;Eureka Client 在程序关闭时向 Eureka Server 发送取消请求。 发送请求后，该客户端实例信息将从 Eureka Server 的实例注册表中删除。<strong>该下线请求不会自动完成</strong>，它必须调用以下内容（意味着直接关闭客户端不会在注册表中删除，因为少调用了以下代码）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">DiscoveryManager</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">shutdownComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p><strong>GetRegisty:  获取注册列表信息</strong> </p>\n<p>&emsp;&emsp;Eureka Client 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息<strong>定期（每30秒钟）更新一次</strong>（数据一致性）。每次返回注册列表信息可能与 Eureka Client 的缓存信息不同，Eureka Client 自动处理。</p>\n<p>&emsp;&emsp;如何判断信息是否更新了？不是将所有信息全部拉取下来进行比对，此时网络传输量过大。</p>\n<p>&emsp;&emsp;传输信息指纹码（MD5加密或HashCode码），数据进行MD5运算后得到唯一的数值，将这个数值拉取到本地来进行比对，如果数值没有变化，则表示信息没有更新。如果指纹码与本地指纹码不同，则拉取更新后的数据。</p>\n<p>&emsp;&emsp;如果由于某种原因导致注册列表信息不能及时匹配，Eureka Client 则会重新获取整个注册表信息。 <strong>Eureka Server 缓存注册列表信息</strong>，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka Client 和 Eureka Server 可以使用 json/xml 格式进行通讯。在默认情况下 Eureka Client 使用压缩 json 格式来获取注册列表的信息。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># 启用服务消费者从注册中心拉取服务列表的功能</span>\neureka.client.fetch<span class=\"token punctuation\">-</span>registry=true\n<span class=\"token comment\"># 设置服务消费者从注册中心拉取服务列表的间隔</span>\neureka.client.registry<span class=\"token punctuation\">-</span>fetch<span class=\"token punctuation\">-</span>interval<span class=\"token punctuation\">-</span>seconds=30<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p><strong>Remote Call:  远程调用</strong> </p>\n<p>&emsp;&emsp;当 Eureka Client 从注册中心获取到服务提供者信息后，就可以通过 Http 请求调用对应的服务；服务提供者有多个时，Eureka Client 客户端会通过 Ribbon <strong>自动进行负载均衡</strong>。</p>\n</li>\n</ol>\n<h1 id=\"二-自我保护机制\"><a href=\"#二-自我保护机制\" class=\"headerlink\" title=\"二. 自我保护机制\"></a>二. 自我保护机制</h1><p>&emsp;&emsp;默认情况下，如果 Eureka Server 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，Eureka 开发了自我保护机制。</p>\n<p>&emsp;&emsp; Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否<strong>低于 85%<strong>，如果低于 85%，Eureka Server 即会</strong>进入自我保护机制</strong>。</p>\n<p><img src=\"Eureka%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/image-20201025182006057.png\" alt=\"EureKa Server进入自我保护机制的状态\"></p>\n<p><strong>Eureka Server 进入自我保护机制，会出现以下几种情况：</strong></p>\n<ol>\n<li><p>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</p>\n</li>\n<li><p>Eureka <strong>仍然能够接受新服务的注册和查询请求</strong>，但是<strong>不会被同步到其它节点上</strong>(即保证当前节点依然可用)</p>\n</li>\n<li><p>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</p>\n</li>\n</ol>\n<p>&emsp;&emsp;Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。</p>\n<p>&emsp;&emsp;如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">eureka.server.enable<span class=\"token punctuation\">-</span>self<span class=\"token punctuation\">-</span>preservation=true   <span class=\"token comment\"># 开启自我保护机制</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h1 id=\"三、EureKa-集群工作原理\"><a href=\"#三、EureKa-集群工作原理\" class=\"headerlink\" title=\"三、EureKa 集群工作原理\"></a>三、EureKa 集群工作原理</h1><p>&emsp;&emsp;Eureka Server 集群相互之间通过 Replicate 来同步数据，相互之间<strong>不区分主节点和从节点</strong>，所有的节点都是平等的（独立关系）。在这种架构中，节点通过<strong>彼此互相注册</strong>来提高可用性，每个节点需要添加一个或多个有效的 <strong>serviceUrl</strong> 指向其他节点。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">service-url</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">defaultZone</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka1<span class=\"token punctuation\">:</span>7001/eureka<span class=\"token punctuation\">,</span>http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka2<span class=\"token punctuation\">:</span>7002/eureka<span class=\"token punctuation\">,</span>http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka3<span class=\"token punctuation\">:</span>7003/eureka<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>&emsp;&emsp;如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点。</p>\n<p>&emsp;&emsp;因为生产端（provider）/消费端（consumer）–&gt;皆为 Server，同样配置了 defaultZone 信息</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">eureka</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token key atrule\">client</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 客户端进行Eureka注册的配置</span>\n\t\t<span class=\"token key atrule\">service-url</span><span class=\"token punctuation\">:</span>\n      \t\t<span class=\"token key atrule\">defaultZone</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka1<span class=\"token punctuation\">:</span>7001/eureka<span class=\"token punctuation\">,</span>http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka2<span class=\"token punctuation\">:</span>7002/eureka<span class=\"token punctuation\">,</span>http<span class=\"token punctuation\">:</span>//admin<span class=\"token punctuation\">:</span>a@eureka3<span class=\"token punctuation\">:</span>7003/eureka<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>&emsp;&emsp;当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 Eureka Server 当前所知的所有节点中，完成数据同步。</p>\n<p>&emsp;&emsp;另外 Eureka Server 的同步遵循着一个非常简单的原则：<strong>只要有一条边将节点连接</strong>，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间<strong>两两连接</strong>起来形成通路，那么其它注册中心都可以共享信息。每个 Eureka Server 同时也是 Eureka Client，多个 Eureka Server 之间通过 <strong>P2P</strong> 的方式完成服务注册表的同步。</p>\n<p>&emsp;&emsp;<strong>Eurka 保证 AP</strong>( 可用性（Availability）、分区容错性（Partition tolerance） ) , 而不保证 C ( 一致性（Consistency）) </p>\n<p>&emsp;&emsp;Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka Client 在向某个 Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>\n","feature":true,"text":"一、EureKa核心概念Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。 整体上可以分为两个主体：Eureka Server 和 Eureka Client. Service provider(服务提供者：负责服务...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":1,"path":"api/categories/Java.json"},{"name":"SpringCloude","slug":"Java/SpringCloude","count":1,"path":"api/categories/Java/SpringCloude.json"},{"name":"EureKa","slug":"EureKa","count":1,"path":"api/categories/EureKa.json"}],"tags":[{"name":"SpringCloude","slug":"SpringCloude","count":1,"path":"api/tags/SpringCloude.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81EureKa%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">一、EureKa核心概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Eureka-Server%EF%BC%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">Eureka Server：注册中心服务端</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Eureka-Client%EF%BC%9A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">Eureka Client：注册中心客户端</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">二. 自我保护机制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81EureKa-%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">三、EureKa 集群工作原理</span></a></li></ol>","author":{"name":"SongX_","slug":"blog-author","avatar":"https://z3.ax1x.com/2021/07/18/W3gCA1.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2021-07-18T04:40:49.886Z","updated":"2021-07-18T04:40:49.886Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":430,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"SongX_","slug":"blog-author","avatar":"https://z3.ax1x.com/2021/07/18/W3gCA1.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}