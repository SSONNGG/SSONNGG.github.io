[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\ntitle: 宋宋 の Blog 施工档案cover: https://z3.ax1x.com/2021/07/25/WgDE0H.pngdate: 2020-07-12 23:10:55feature: truemath: truetags: 置顶excerpt: 宋宋的Blog已经重新启动，目前正在维护相关文章，修复相关问题中….. 注意：HelloWorld文章暂用于测试。\n2021.7.25施工档案图片链接可用\n封面可以正常显示\n上传了部分文章\n\n\n\n\n\n\n\n目前存在的问题\n代码高亮偶现不显示\n评论无法使用\n\n\n2021.7.18施工档案博客主题重置\n博客维护完毕\n文章暂未上线，后续补充上线\n\n\n\n\n\n\n\n目前存在的问题\n图片链接失效\n评论功能暂时无法使用\n封面无法正常显示\n\n\n2021.2.01施工档案将代码样式由 ‘Github Gist’ 改为 ‘Tomorrow Night Eighties’ \n2021.1.13施工档案修改了config.yml文件，以及将SSH部署到Github上，现在可以不用反复输入github账号和密码可以直接上传写好的文章了。\n升级了 Hexo 版本到5.3.0\n关于页面补充添加了2021年寒假计划，望监督。\n2020.7.22施工档案\n修改了主页默认背景图\n修改了文章默认背景图\n将顶部导航栏的颜色值由 #26679d修改为 #2f71a3\n添加了关于页面的博客介绍\n\n2020.7.19施工档案\n修改对KateX公式块的支持。\n现在可以正常显示复杂的数学公式，便于书写数学公式（需要在 Font-matter 中加入 math 标签）\n\n\n$$\\lim_{n \\to +\\infty}{f(n)/n^3}=\\lim_{n \\to +\\infty}{2n^3+3n^2+2n+1}/n^3$$\n\n同时修改了文章标签与文章类型的逻辑，标签现在不具备多级属性。\n\n2020.7.12晚间施工欢迎来到宋宋的博客，本博客基于Github资源库搭建，会上传如下内容，欢迎评论留言建议\n\n学习笔记\n辩论相关\n编程相关\nIDE配置\n\n正式上线，处于测试期，欢迎至微信、QQ、微博等社交平台提出您的建议。\n如有可优化的部分会尽快安排优化\n目前在安排的优化内容：\n\n评论回复邮件提醒\nabout页面内容\n\n","slug":"公告","date":"2021-07-19T03:12:26.463Z","categories_index":"","tags_index":"","author_index":"SongX_"},{"id":"8d800d163db722a0bbd28451e306e75e","title":"算法 | 并查集","content":"&emsp;&emsp;原文地址：零基础彻底弄懂”并查集”\n&emsp;&emsp;最近在 LeetCode 上尝试提升自己的算法能力，在研究过程中，评论区常常提到一个词——“并查集”。秉着好奇的心理，我就尝试去了解了一下，发现这个算法还是挺重要挺有难度的，特此转载这篇文章，非常感谢文章作者（其中也有某些自己的思考）。感谢！\n&emsp;&emsp;并查集也称为不相交集数据结构。此算法的发展经历了十多年，研究它的人也很多，其中 Robert E. Tarjan 做出了很大的贡献。在此之前 John E. Hopcroft 和 Jeffrey D. Ullman 也进行了大量的分析。你是不是又感觉Robert E. Tarjan和John E. Hopcroft很熟悉？没错，就是发明了深度优先搜索的两个人——1986年的图灵奖得主。其实树还有很多神奇的用法，比如：线段树、树状数组、Trie树（字典树）、二叉搜索树、红黑树（是一种平衡二叉搜索树）等等。\n&emsp;&emsp;咱们从一个故事说起——解密犯罪团伙。\n\n&emsp;&emsp;快过年了，犯罪分子们也开始为年终奖“奋斗”了，小哼的家乡出现了多次抢劫事件。由于强盗人数过于庞大，作案频繁，警方想查清楚到底有几个犯罪团伙实在是太不容易了，不过警察叔叔还是搜集到了一些线索，需要咱们帮忙分析一下。\n&emsp;&emsp;现在有11个强盗。\n&emsp;&emsp;1号强盗与2号强盗是同伙。\n&emsp;&emsp;3号强盗与4号强盗是同伙。\n&emsp;&emsp;5号强盗与2号强盗是同伙。\n&emsp;&emsp;4号强盗与6号强盗是同伙。\n&emsp;&emsp;2号强盗与6号强盗是同伙。\n&emsp;&emsp;7号强盗与11号强盗是同伙。\n&emsp;&emsp;8号强盗与7号强盗是同伙。\n&emsp;&emsp;9号强盗与7号强盗是同伙。\n&emsp;&emsp;9号强盗与11号强盗是同伙。\n&emsp;&emsp;1号强盗与6号强盗是同伙。\n&emsp;&emsp;注意：强盗同伙的同伙也是同伙。你能帮助警方查出有多少个独立的犯罪团伙吗？\n&emsp;&emsp;要想解决这个问题，首先我们假设这11个强盗相互是不认识的，他们各自为政，每个人都是首领，他们只听从自己的。之后我们将通过警方提供的线索，一步步地来“合并同伙”。\n&emsp;&emsp;第一步：我们申请一个一维数组f，我们用f[1] ~ f[11]分别存储1 ~ 11号强盗中每个强盗的首领“BOSS”是谁。\n&emsp;&emsp;第二步：初始化。根据我们之前的约定，这11个强盗最开始是各自为政的，每个强盗的BOSS就是自己。“1号强盗”的BOSS就是“1号强盗”自己，因此f[1]的值为1。以此类推，“11号强盗”的BOSS是“11号强盗”，即f[11]的值为11。请注意，这是很重要的一步。\n\n&emsp;&emsp;我们用数组下标来表示强盗的编号\n&emsp;&emsp;每个单元格中存储的是每个强盗的“BOSS”是谁\n&emsp;&emsp;第三步：开始“合并同伙”。即如果发现目前两个强盗是同伙，则这两个强盗是同一个犯罪团伙。现在有一个问题：合并之后谁才是这个犯罪团伙的BOSS呢？\n&emsp;&emsp;例如：警方得到的第1条线索是“1号强盗与2号强盗是同伙”。\n&emsp;&emsp;“1号强盗”和“2号强盗”原来的BOSS都是自己，如今发现“1号强盗”和“2号强盗”其实是同一个犯罪团伙，那么究竟是让“1号强盗”变成“2号强盗”的BOSS，还是让“2号强盗”变成“1号强盗”的BOSS呢？一个犯罪团伙只能有一个首领。其实无所谓，都可以。我们这里假定左边的强盗更厉害一些，给这个规定起个名字叫作“靠左”法则。也就是说“2号强盗”的BOSS将变成“1号强盗”。因此我们将f[2]中的数改为1，表明“2号强盗”归顺了“1号强盗”。其实准确地说应该是原本归顺“2号强盗”的所有人都归顺了“1号强盗”才对，只不过此时“2号强盗”只孤身一人，因此只需要将f[2]的值改为1。不要着急，继续往后面看，你就知道我为什么这样说了，如下：\n\n\n&emsp;&emsp;警方得到的第2条线索是“3号强盗与4号强盗是同伙”，说明“3号强盗”和“4号强盗”也是同一个犯罪团伙。根据“靠左”原则“4号强盗”归顺了“3号强盗”，所以f[4]中的值要改为3，原理和刚才处理第1条线索是一样的，如下。\n\n\n&emsp;&emsp;警方得到的第3条线索是“5号强盗”与“2号强盗”是同伙。f[5]的值是5，说明“5号强盗”的BOSS仍然是自己。f[2]的值是1，说明“2号强盗”的BOSS是“1号强盗”。根据“靠左”法则，右边的强盗必须归顺于左边的强盗。此时你可能会将f[2]的值改为5。注意啦！此时如果你将f[2]的值改为5，就是说让“2号强盗”归顺“5号强盗”。那“1号强盗”可就不干了，你凭什么抢我的人？他非跟你干一架不可。这样会让“2号强盗”很难选择，我究竟归顺谁好呢？\n\n&emsp;&emsp;现在我来给你支个招，古语云“擒贼先擒王”。你直接找“2号强盗”的BOSS“1号强盗”谈，让其归顺“5号强盗”就OK了，也就是将f[1]的值改为5。现在“2号强盗”的BOSS是“1号强盗”，而“1号强盗”的BOSS变成了“5号强盗”，即“1号强盗”带领手下“2号强盗”归顺了“5号强盗”，这样所有的关系信息就都保留下来了。如下。\n\n\n&emsp;&emsp;警方得到的第4条线索是“4号强盗”与“6号强盗”是同伙。f[4]的值是3，f[6]的值是6。根据“靠左”原则，让“6号强盗”加入“3号犯罪团伙”，我们需要将f[6]的值改为3。原理和处理第1条和第2条线索相同。\n\n\n&emsp;&emsp;警方得到的第5条线索是“2号强盗”与“6号强盗”是同伙。f[2]的值是1，f[1]的值是5，即“2号强盗”的大BOSS（首领）是“5号强盗”。f[6]的值是3，即“6号强盗”的BOSS是“3号强盗”。根据“靠左”原则和“擒贼先擒王”原则，让“6号强盗”的BOSS“3号强盗”归顺“2号强盗”的大BOSS（首领）“5号强盗”。因此我们需要将f[3]的值改为5，即让“3号强盗”带领其手下归顺“5号强盗”。\n&emsp;&emsp;需要特别注意的是，此时，“5号强盗”团伙内部发生了一些变动。我们在寻找“2号强盗”的大BOSS（首领）是谁时，顺带将f[2]从1改成了5，也就是说现在“2号强盗”也变成大BOSS（首领）“5号强盗”的直属手下了。\n&emsp;&emsp;这就是强盗团伙的江湖规矩，谁能找到自己帮派的大BOSS（首领），谁就会被大BOSS（首领）提拔，升职加薪，成为大BOSS（首领）的直属手下。这种扁平化管理的方式可以有效地提高强盗团伙找大BOSS的效率，在“并查集”算法中有一个专门的术语，叫作“路径压缩”，具体代码在后面展示。\n\n\n&emsp;&emsp;细心的同学会问了，刚才不是说如果直接把f[2]改成5，“2号强盗”和“1号强盗”之间的关系就断了吗？此一时，彼一时。在得到第3条线索的时候，那时候“1号强盗”和“5号强盗”的关系还没有建立起来，如果把f[2]改为5，“2号强盗”想要找 “1号强盗”就找不到了。但到了第5条线索的时候，“2号强盗”和“1号强盗”已经都在大BOSS（首领）“5号强盗”手下工作了，这时候将f[2]改为5，“2号强盗”想找大BOSS（首领）“5号强盗”变得更加方便，而“1号强盗”和“2号强盗”之间的关系也没有丢失，因此整体上效率变得更高了。\n&emsp;&emsp;警方得到的第6条线索是“7号强盗”与“11号强盗”是同伙。f[11]的值是11，f[7]的值是7。根据“靠左”原则，让“11号强盗”归顺“7号强盗”。我们需要将f[11]的值改为7。\n\n\n&emsp;&emsp;警方得到的第7条线索是“8号强盗”与“7号强盗”是同伙。f[8]的值是8，f[7]的值是7。根据“靠左”原则，让“7号强盗”归顺“8号强盗”。我们需要将f[7]的值改为8。\n\n\n&emsp;&emsp;警方得到的第8条线索是“9号强盗”与“7号强盗”是同伙。f[9]的值是9，f[7]的值是8。根据“靠左”原则和“擒贼先擒王”原则，我们需要将f[8]的值改为9。\n\n\n&emsp;&emsp;警方得到的第9条线索是“9号强盗”与“11号强盗”是同伙。f[9]的值是9，f[11]的值是7。什么？他们竟然不在同一个犯罪团伙中？这貌似不对吧，通过上图可以很显然地看出来“11号强盗”和“9号强盗”都在同一个犯罪团伙中。不过“11号强盗”并不直属于大BOSS（首领）“9号强盗”，而是归顺在“7号强盗”的手下。现在来看看“7号强盗”又归顺了谁呢？我们发现f[7]=8，也就是说“7号强盗”归顺了“8号强盗”。而f[8]=9，也就是说“8号强盗”归顺了“9号强盗”。我们再来看看“9号强盗”有没有归顺于别的人。发现f[9]的值还是9，太牛了！说明“9号强盗”的BOSS仍然是自己，他就是所在团伙的大BOSS（首领）。\n&emsp;&emsp;我们刚才模拟的过程其实就是递归的过程。从“11号强盗”顺藤摸瓜一直找到他所在团伙的大BOSS（首领）“9号强盗”。刚才说了，强盗团伙的江湖规矩是，谁能找到自己帮派的大BOSS（首领），就会被提拔为首领的直属手下。经过这一次“路径压缩”，一路上“11号强盗”“7号强盗”和“8号强盗”，都找到了自己的大BOSS“9号强盗”。下次再问他们的BOSS是谁的时候，他们就能马上回答出是“9号强盗”啦。\n\n\n&emsp;&emsp;警方得到的最后一条线索是“1号强盗”与“6号强盗”是同伙。这又是一次“路径压缩”的过程。f[1]是5，“1号强盗”的BOSS是“5号强盗”。f[6]是3，“6号强盗”的BOSS是“3号强盗”。f[3]是5，“3号强盗”的BOSS是“5号强盗”。说明“6号强盗”和“1号强盗”是在一个团伙中的，但他现在并不是直接跟着团伙的大BOSS（首领）“5号强盗”，而是跟着“3号强盗”。而经过这次“路径压缩”，他的BOSS就改成了“5号强盗”。但是注意，这一次的“路径压缩”只发生在“6号强盗”“3号强盗”“5号强盗”这条路径上，团伙中的“4号强盗”不在被压缩的路径上，所以他的BOSS暂时不会改变，还是“3号强盗”。\n\n\n&emsp;&emsp;好了，所有的线索分析完毕，那么究竟有多少个犯罪团伙呢？我想你从上面的图中一眼就可以看出来了，一共有3个犯罪团伙，分别是5号犯罪团伙（由5、1、2、3、4、6号强盗组成），9号犯罪团伙（由9、8、7、11号强盗组成）以及10号犯罪团伙（只有10号强盗一个人）。从下面这张图就可以清晰地看出，如果f[i]=i，就表示此人是一个犯罪团伙的最高领导人，有多少个最高领导人就是有多少个“独立的犯罪团伙”。最后数组中f[5]=5、f[9]=9、f[10]=10，因此有3个独立的犯罪团伙。\n\n&emsp;&emsp;我们刚才模拟的过程其实就是并查集的算法。并查集通过一个一维数组来实现，其本质是维护一个森林。刚开始的时候，森林的每个点都是孤立的，也可以理解为每个点就是一棵只有一个结点的树，之后通过一些条件，逐渐将这些树合并成一棵大树。其实合并的过程就是“认爹”的过程。在“认爹”的过程中，要遵守“靠左”原则和“擒贼先擒王”原则。在每次判断两个结点是否已经在同一棵树中的时候（一棵树其实就是一个集合），也要注意必须求其根源，中间父亲结点（“小BOSS”）是不能说明问题的，必须找到其祖宗（树的根结点），判断两个结点的祖宗是否是同一个根结点才行。下面我将“解密犯罪团伙”这个问题模型化，并给出代码和注释：\n#include &lt;stdio.h&gt;   \nint f[1001]&#x3D;&#123;0&#125;,n,m,sum&#x3D;0;   \n&#x2F;&#x2F;这里是初始化，非常地重要，数组里面存的是自己数组下标的编号就好了。   \nvoid init()   \n&#123;   \n    int i;   \n    for(i&#x3D;1;i&lt;&#x3D;n;i++)   \n        f[i]&#x3D;i;   \n    return;\n&#125;   \n&#x2F;&#x2F;这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人，\n&#x2F;&#x2F;“擒贼先擒王”原则。\nint getf(int v)   \n&#123;   \n    if(f[v]&#x3D;&#x3D;v)   \n        return v;   \n    else  \n    &#123;   \n        &#x2F;&#x2F;这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”改为最后找\n        &#x2F;&#x2F;到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高今后找到犯罪团伙的\n        &#x2F;&#x2F;最高领导人（其实就是树的祖先）的速度。\n        f[v]&#x3D;getf(f[v]);&#x2F;&#x2F;这里进行了路径压缩\n        return f[v];   \n    &#125;   \n&#125;   \n&#x2F;&#x2F;这里是合并两子集合的函数\nvoid merge(int v,int u)   \n&#123;   \n    int t1,t2;&#x2F;&#x2F;t1、t2分别为v和u的大BOSS（首领），每次双方的会谈都必须是各自最高领导人才行\n    t1&#x3D;getf(v);\n    t2&#x3D;getf(u);\n    if( t1!&#x3D;t2 ) &#x2F;&#x2F;判断两个结点是否在同一个集合中，即是否为同一个祖先。\n    &#123;  \n        f[t2]&#x3D;t1;\n             &#x2F;&#x2F;“靠左”原则，左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合。\n    &#125;\n    return;\n&#125;   \n  \n&#x2F;&#x2F;请从此处开始阅读程序，从主函数开始阅读程序是一个好习惯。\nint main()   \n&#123;     \n    int i,x,y;   \n    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);   \n  \n    init();  &#x2F;&#x2F;初始化是必须的\n    for(i&#x3D;1;i&lt;&#x3D;m;i++)   \n    &#123;   \n        &#x2F;&#x2F;开始合并犯罪团伙   \n        scanf(&quot;%d %d&quot;,&amp;x,&amp;y);   \n        merge(x,y);   \n    &#125;\n\n    &#x2F;&#x2F;最后扫描有多少个独立的犯罪团伙\n    for(i&#x3D;1;i&lt;&#x3D;n;i++)\n    &#123;\n        if(f[i]&#x3D;&#x3D;i)\n            sum++;\n    &#125;\n    printf(&quot;%d\\n&quot;,sum);\n    getchar();getchar();\n    return 0;   \n&#125;\n\n&emsp;&emsp;可以输入以下数据进行验证。第一行n m，n表示强盗的人数，m表示警方搜集到的m条线索。接下来的m行每一行有两个数a和b，表示强盗a和强盗b是同伙。\n11 10\n1 2\n3 4\n5 2\n4 6\n2 6\n7 11\n8 7\n9 7\n9 11\n1 6\n运行结果是：\n3\n\n","slug":"算法-并查集","date":"2021-01-22T06:37:47.000Z","categories_index":"数据结构,C,算法","tags_index":"笔记","author_index":"SongX_"},{"id":"16e16a971c2690fe161fa7eece5339e5","title":"Eureka相关理论","content":"一、EureKa核心概念Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。\n整体上可以分为两个主体：Eureka Server 和 Eureka Client. Service provider(服务提供者：负责服务注册和续约的操作) 和 Service consumer(服务消费者：负责获取服务注册的信息) 本质都是Eureka Client.\nEureKa 保证了 CAP 中的 AP（即可用性和分区容忍性）\nEureKa中注册信息和服务器上的信息保证了最终一致性（即服务器宕掉之后仍旧能使用，上线后再次进行同步。不考虑中间不一致）\nEureka Server：注册中心服务端\n服务注册: \n服务提供者启动时，会通过 Eureka Client 向 Eureka Server 发送 REST请求 的方式向 Eureka Server 注册自己的服务信息数据，这些数据是服务自身的元数据，比如ip地址、端口、运行状况指标的url、主页地址等信息, Eureka Server 会存储该服务的信息，Eureka Server 内部有二层缓存机制 (一个双层的Map) 中来维护整个注册表。\n\n\n提供注册表: \n服务消费者在调用服务时，如果 Eureka Client 没有缓存注册表的话，会从 Eureka Server 获取最新的注册表。\n\n同步状态: \nEureka Client 通过注册、心跳机制和 Eureka Server 同步当前客户端的状态。\n\nEviction 服务剔除：\n当 Eureka Client 和 Eureka Server 不再有心跳时，Eureka Server 会将该服务实例从服务注册列表中删除，即服务剔除。\n\n\nEureka Client：注册中心客户端&emsp;&emsp;它是一个 Java 客户端，用于简化与 Eureka Server 的交互。Eureka Client 会拉取、更新和缓存Eureka Server 中的信息。因此当所有的 Eureka Server 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致. (分布式集群最重要的问题：如何保持数据的一致性？EureKa满足最终一致，因为 EureKa 需要保持 CAP 中的 AP )\n\nRegister:  服务注册\n服务的提供者, 将自身注册到注册中心，服务提供者也是一个 Eureka Client。\n\nRenew:  服务续约\n&emsp;&emsp;Eureka Client 会每隔 30 秒发送一次心跳来续约。 通过续约来告知 Eureka Server 该 Eureka Client 运行正常，没有出现问题。 默认情况下，如果 Eureka Server 在 90 秒内没有收到 Eureka Client 的续约，Server 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。\n有关修改服务续约调用时间的属性（可在application.yml中修改）：\n# 服务续约任务的调用间隔时间，默认为30秒\neureka.instance.lease-renewal-interval-in-seconds=30\n# 服务失效的时间，默认为90秒。\neureka.instance.lease-expiration-duration-in-seconds=90\nCancel:  服务下线 \n&emsp;&emsp;Eureka Client 在程序关闭时向 Eureka Server 发送取消请求。 发送请求后，该客户端实例信息将从 Eureka Server 的实例注册表中删除。该下线请求不会自动完成，它必须调用以下内容（意味着直接关闭客户端不会在注册表中删除，因为少调用了以下代码）：\nDiscoveryManager.getInstance().shutdownComponent();\nGetRegisty:  获取注册列表信息 \n&emsp;&emsp;Eureka Client 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次（数据一致性）。每次返回注册列表信息可能与 Eureka Client 的缓存信息不同，Eureka Client 自动处理。\n&emsp;&emsp;如何判断信息是否更新了？不是将所有信息全部拉取下来进行比对，此时网络传输量过大。\n&emsp;&emsp;传输信息指纹码（MD5加密或HashCode码），数据进行MD5运算后得到唯一的数值，将这个数值拉取到本地来进行比对，如果数值没有变化，则表示信息没有更新。如果指纹码与本地指纹码不同，则拉取更新后的数据。\n&emsp;&emsp;如果由于某种原因导致注册列表信息不能及时匹配，Eureka Client 则会重新获取整个注册表信息。 Eureka Server 缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka Client 和 Eureka Server 可以使用 json/xml 格式进行通讯。在默认情况下 Eureka Client 使用压缩 json 格式来获取注册列表的信息。\n# 启用服务消费者从注册中心拉取服务列表的功能\neureka.client.fetch-registry=true\n# 设置服务消费者从注册中心拉取服务列表的间隔\neureka.client.registry-fetch-interval-seconds=30\nRemote Call:  远程调用 \n&emsp;&emsp;当 Eureka Client 从注册中心获取到服务提供者信息后，就可以通过 Http 请求调用对应的服务；服务提供者有多个时，Eureka Client 客户端会通过 Ribbon 自动进行负载均衡。\n\n\n二. 自我保护机制&emsp;&emsp;默认情况下，如果 Eureka Server 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，Eureka 开发了自我保护机制。\n&emsp;&emsp; Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 即会进入自我保护机制。\n\nEureka Server 进入自我保护机制，会出现以下几种情况：\n\nEureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务\n\nEureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)\n\n当网络稳定时，当前实例新的注册信息会被同步到其它节点中\n\n\n&emsp;&emsp;Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 Eureka 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。\n&emsp;&emsp;如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。\neureka.server.enable-self-preservation=true   # 开启自我保护机制\n\n三、EureKa 集群工作原理&emsp;&emsp;Eureka Server 集群相互之间通过 Replicate 来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的（独立关系）。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。\nservice-url:\n\tdefaultZone: http://admin:a@eureka1:7001/eureka,http://admin:a@eureka2:7002/eureka,http://admin:a@eureka3:7003/eureka\n\n&emsp;&emsp;如果某台 Eureka Server 宕机，Eureka Client 的请求会自动切换到新的 Eureka Server 节点。\n&emsp;&emsp;因为生产端（provider）/消费端（consumer）–&gt;皆为 Server，同样配置了 defaultZone 信息\neureka:\n\tclient: # 客户端进行Eureka注册的配置\n\t\tservice-url:\n      \t\tdefaultZone: http://admin:a@eureka1:7001/eureka,http://admin:a@eureka2:7002/eureka,http://admin:a@eureka3:7003/eureka\n\n&emsp;&emsp;当宕机的服务器重新恢复后，Eureka 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 Eureka Server 当前所知的所有节点中，完成数据同步。\n&emsp;&emsp;另外 Eureka Server 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 Eureka Server 同时也是 Eureka Client，多个 Eureka Server 之间通过 P2P 的方式完成服务注册表的同步。\n&emsp;&emsp;Eurka 保证 AP( 可用性（Availability）、分区容错性（Partition tolerance） ) , 而不保证 C ( 一致性（Consistency）) \n&emsp;&emsp;Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka Client 在向某个 Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 Eureka Server 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。\n","slug":"Eureka相关理论","date":"2020-10-25T09:32:51.000Z","categories_index":"Java,SpringCloude,EureKa","tags_index":"SpringCloude","author_index":"SongX_"},{"id":"31d5cedf656bd0b6317d2ab32b6a27f2","title":"SpringBoot启动类源码阅读","content":"&emsp;&emsp;最近在学习 SpringBoot ，老师恰好有布置阅读 SpringBoot 源码的任务，因此决定根据老师的博客文章写一下有关于 SpringBoot 的源码阅读。\n&emsp;&emsp;博客链接\n&emsp;&emsp;我们知道 SpringBoot 是通过启动类 Application 开始运行的，因此我们先从启动类的源码开始阅读（暂时更新到注解部分，运行部分待更新）\n注解部分&emsp;&emsp;SpringBoot 启动类存在注解 @SpringBootApplication 我们进入 @SpringBootApplication 进行阅读\n@SpringBootApplication@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\t//SpringBoot的配置类；标注在某个类上，表示这是一个SpringBoot的配置类；\n@EnableAutoConfiguration\t//开启自动配置功能； 以前我们需要配置的东西，SpringBoot帮我们自动配置；\n@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)\n\n@SpringBootConfiguration@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\t//表示这个类是一个配置类\npublic @interface SpringBootConfiguration &#123;\n&#125;\n\n\n\n@EnableAutoConfiguration@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\t//将添加该注解的类所在的package作为自动配置package 进行管理 \n@Import(AutoConfigurationImportSelector.class)\n\n@Import(AutoConfigurationImportSelector.class)@AutoConfigurationPackage 通过 Import 导入了 AutoConfigurationImportSelector.class\nAutoConfigurationImportSelector.class@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123;\n\t\tif (!isEnabled(annotationMetadata)) &#123;\n\t\t\treturn NO_IMPORTS;\n\t\t&#125;\n\t\tAutoConfigurationMetadata autoConfigurationMetadata &#x3D; AutoConfigurationMetadataLoader\n\t\t\t\t.loadMetadata(this.beanClassLoader);\n\t\tAutoConfigurationEntry autoConfigurationEntry &#x3D; getAutoConfigurationEntry(autoConfigurationMetadata,\n\t\t\t\tannotationMetadata);\t&#x2F;&#x2F;我们重点查看此方法\n\t\treturn StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n\t&#125;\n\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,\n\t\t\tAnnotationMetadata annotationMetadata) &#123;\n\t\tif (!isEnabled(annotationMetadata)) &#123;\n\t\t\treturn EMPTY_ENTRY;\n\t\t&#125;\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n\t\tList&lt;String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\t//用此方法来获取所有的配置项\t\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet&lt;String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = filter(configurations, autoConfigurationMetadata);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn new AutoConfigurationEntry(configurations, exclusions);\n\t&#125;\n\n&emsp;&emsp;接下来我们来寻找获取所有配置项的方法，很容易找到：getCandidateConfigurations\nprotected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;\n\t\tList&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\t&#x2F;&#x2F;进入SpringFactoriesLoader中\n\t\tAssert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you &quot;\n\t\t\t\t+ &quot;are using a custom packaging, make sure that file is correct.&quot;);\n\t\treturn configurations;\n\t&#125;\n\nSpringFactoriesLoaderpublic static List&lt;String> loadFactoryNames(Class&lt;?> factoryClass, @Nullable ClassLoader classLoader) &#123;\n   String factoryClassName = factoryClass.getName();\t//取出工厂类型名\n   return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\t\t//返回值是一个Map\n&#125;\n\n/**\n*\t此方法的返回值是一个Map\n**/\nprivate static Map&lt;String, List&lt;String>> loadSpringFactories(@Nullable ClassLoader classLoader) &#123;\n   MultiValueMap&lt;String, String> result = cache.get(classLoader);\n   if (result != null) &#123;\n      return result;\n   &#125;\n\n   try &#123;\n      Enumeration&lt;URL> urls = (classLoader != null ?\n            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n/**\n*\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\t类加载器在加载\n*\t路径为 FACTORIES_RESOURCE_LOCATION=\"META-INF/spring.factories\"\n*\t此时我们进入 \"META-INF/spring.factories\" 中，可以看到一系列 SpringBoot 自动配置的列表\n**/\n      result = new LinkedMultiValueMap&lt;>();\n      while (urls.hasMoreElements()) &#123;\n         URL url = urls.nextElement();\n         UrlResource resource = new UrlResource(url);\n         Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n         for (Map.Entry&lt;?, ?> entry : properties.entrySet()) &#123;\n            String factoryClassName = ((String) entry.getKey()).trim();\n            for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;\n               result.add(factoryClassName, factoryName.trim());\n            &#125;\n         &#125;\n      &#125;\n      cache.put(classLoader, result);\n      return result;\n   &#125;\n   catch (IOException ex) &#123;\n      throw new IllegalArgumentException(\"Unable to load factories from location [\" +\n            FACTORIES_RESOURCE_LOCATION + \"]\", ex);\n   &#125;\n&#125;\n\n运行部分SpringApplication 类ConfigurableApplicationContext run()方法public ConfigurableApplicationContext run(String... args) &#123;\n\tStopWatch stopWatch = new StopWatch();\n\tstopWatch.start();\n\tConfigurableApplicationContext context = null;\n\tCollection&lt;SpringBootExceptionReporter> exceptionReporters = new ArrayList&lt;>();\n\tconfigureHeadlessProperty();\n\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\tlisteners.starting();\n\ttry &#123;\n\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\t\tconfigureIgnoreBeanInfo(environment);\n\t\tBanner printedBanner = printBanner(environment);\n\t\tcontext = createApplicationContext();\n\t\texceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,\n\t\t\t\tnew Class[] &#123; ConfigurableApplicationContext.class &#125;, context);\n\t\tprepareContext(context, environment, listeners, applicationArguments, printedBanner);\n\t\trefreshContext(context);\t\t//查询此方法\n\t\tafterRefresh(context, applicationArguments);\n\t\tstopWatch.stop();\n\t\tif (this.logStartupInfo) &#123;\n\t\t\tnew StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);\n\t\t&#125;\n\t\tlisteners.started(context);\n\t\tcallRunners(context, applicationArguments);\n\t&#125;\n\tcatch (Throwable ex) &#123;\n\t\thandleRunFailure(context, ex, exceptionReporters, listeners);\n\t\tthrow new IllegalStateException(ex);\n\t&#125;\n\n\ttry &#123;\n\t\tlisteners.running(context);\n\t&#125;\n\tcatch (Throwable ex) &#123;\n\t\thandleRunFailure(context, ex, exceptionReporters, null);\n\t\tthrow new IllegalStateException(ex);\n\t&#125;\n\treturn context;\n&#125;\n\nrefreshContext() 方法private void refreshContext(ConfigurableApplicationContext context) &#123;\n   refresh(context);\t//查询此方法\n   if (this.registerShutdownHook) &#123;\n      try &#123;\n         context.registerShutdownHook();\n      &#125;\n      catch (AccessControlException ex) &#123;\n         // Not allowed in some environments.\n      &#125;\n   &#125;\n&#125;\n\nrefresh()方法protected void refresh(ApplicationContext applicationContext) &#123;\n   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);\n   ((AbstractApplicationContext) applicationContext).refresh();\t//进入此类中\n&#125;\n\nAbstractApplicationContext 类@Override\npublic void refresh() throws BeansException, IllegalStateException &#123;\n   synchronized (this.startupShutdownMonitor) &#123;\n      // Prepare this context for refreshing.\n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      prepareBeanFactory(beanFactory);\n\n      try &#123;\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         //启动工厂处理器以注册 bean 到容器中\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n\n         // Check for listener beans and register them.\n         registerListeners();\n\n         // Instantiate all remaining (non-lazy-init) singletons.\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      &#125;\n\n      catch (BeansException ex) &#123;\n         if (logger.isWarnEnabled()) &#123;\n            logger.warn(\"Exception encountered during context initialization - \" +\n                  \"cancelling refresh attempt: \" + ex);\n         &#125;\n\n         // Destroy already created singletons to avoid dangling resources.\n         destroyBeans();\n\n         // Reset 'active' flag.\n         cancelRefresh(ex);\n\n         // Propagate exception to caller.\n         throw ex;\n      &#125;\n\n      finally &#123;\n         // Reset common introspection caches in Spring's core, since we\n         // might not ever need metadata for singleton beans anymore...\n         resetCommonCaches();\n      &#125;\n   &#125;\n&#125;\n\ninvokeBeanFactoryPostProcessors() 方法protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;\n   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\t//进入此方法中\n\n   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;\n      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n   &#125;\n&#125;\n\ninvokeBeanFactoryPostProcessors() 方法public static void invokeBeanFactoryPostProcessors(\n      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor> beanFactoryPostProcessors) &#123;\n\n   // Invoke BeanDefinitionRegistryPostProcessors first, if any.\n  \n\n\n      // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.\n     \n      // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.\n     \n\n      // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.\n    \n\n      // Now, invoke the postProcessBeanFactory callback of all processors handled so far.\n      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\t//进入此方法中\n      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n   &#125;\n\n   else &#123;\n      // Invoke factory processors registered with the context instance.\n      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);\n   &#125;\n\n   // Do not initialize FactoryBeans here: We need to leave all regular beans\n   // uninitialized to let the bean factory post-processors apply to them!\n   String[] postProcessorNames =\n         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);\n\n   // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,\n   // Ordered, and the rest.\n   List&lt;BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList&lt;>();\n   List&lt;String> orderedPostProcessorNames = new ArrayList&lt;>();\n   List&lt;String> nonOrderedPostProcessorNames = new ArrayList&lt;>();\n   for (String ppName : postProcessorNames) &#123;\n      if (processedBeans.contains(ppName)) &#123;\n         // skip - already processed in first phase above\n      &#125;\n      else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;\n         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));\n      &#125;\n      else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;\n         orderedPostProcessorNames.add(ppName);\n      &#125;\n      else &#123;\n         nonOrderedPostProcessorNames.add(ppName);\n      &#125;\n   &#125;\n\n   // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.\n   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\n   // Next, invoke the BeanFactoryPostProcessors that implement Ordered.\n   List&lt;BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList&lt;>();\n   for (String postProcessorName : orderedPostProcessorNames) &#123;\n      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   &#125;\n   sortPostProcessors(orderedPostProcessors, beanFactory);\n   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);\n\n   // Finally, invoke all other BeanFactoryPostProcessors.\n   List&lt;BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList&lt;>();\n   for (String postProcessorName : nonOrderedPostProcessorNames) &#123;\n      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));\n   &#125;\n   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);\n\n   // Clear cached merged bean definitions since the post-processors might have\n   // modified the original metadata, e.g. replacing placeholders in values...\n   beanFactory.clearMetadataCache();\n&#125;\n\ninvokeBeanFactoryPostProcessors() 方法private static void invokeBeanFactoryPostProcessors(\n      Collection&lt;? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) &#123;\n\n   for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;\t//注意：这里的BeanFactoryPostFactory是一个接口，它下面的 org.springframework.context.annotation.ConfigurationClassPostProcessor 类才是我们要看的.\n      postProcessor.postProcessBeanFactory(beanFactory);\n   &#125;\n&#125;\n\nConfigurationClassPostProcessor 类postProcessBeanFactory() 方法@Override\n\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;\n\t\tint factoryId = System.identityHashCode(beanFactory);\n\t\tif (this.factoriesPostProcessed.contains(factoryId)) &#123;\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"postProcessBeanFactory already called on this post-processor against \" + beanFactory);\n\t\t&#125;\n\t\tthis.factoriesPostProcessed.add(factoryId);\n\t\tif (!this.registriesPostProcessed.contains(factoryId)) &#123;\n\t\t\t// BeanDefinitionRegistryPostProcessor hook apparently not supported...\n\t\t\t// Simply call processConfigurationClasses lazily at this point then.\n\t\t\tprocessConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);\t//处理有注解的bean的定义\n\t\t&#125;\n\n\t\tenhanceConfigurationClasses(beanFactory);\n\t\tbeanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));\n\t&#125;\n\nprocessConfigBeanDefinitions() 方法public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;\n   List&lt;BeanDefinitionHolder> configCandidates = new ArrayList&lt;>();\n   String[] candidateNames = registry.getBeanDefinitionNames();\n\n   for (String beanName : candidateNames) &#123;\n      BeanDefinition beanDef = registry.getBeanDefinition(beanName);\n      if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;\n         if (logger.isDebugEnabled()) &#123;\n            logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n         &#125;\n      &#125;\n      else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;\n         configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\t//candidates读取的被@Cofiguration注解的类\n      &#125;\n   &#125;\n\n   // Return immediately if no @Configuration classes were found\n   if (configCandidates.isEmpty()) &#123;\n      return;\n   &#125;\n\n   // Sort by previously determined @Order value, if applicable\n   configCandidates.sort((bd1, bd2) -> &#123;\n      int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n      int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n      return Integer.compare(i1, i2);\n   &#125;);\n\n   // Detect any custom bean name generation strategy supplied through the enclosing application context\n   SingletonBeanRegistry sbr = null;\n   if (registry instanceof SingletonBeanRegistry) &#123;\n      sbr = (SingletonBeanRegistry) registry;\n      if (!this.localBeanNameGeneratorSet) &#123;\n         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n         if (generator != null) &#123;\n            this.componentScanBeanNameGenerator = generator;\n            this.importBeanNameGenerator = generator;\n         &#125;\n      &#125;\n   &#125;\n\n   if (this.environment == null) &#123;\n      this.environment = new StandardEnvironment();\n   &#125;\n\n   // Parse each @Configuration class\n   //从这里开始解析 @Configuration 注解\n   ConfigurationClassParser parser = new ConfigurationClassParser(\n         this.metadataReaderFactory, this.problemReporter, this.environment,\n         this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n   Set&lt;BeanDefinitionHolder> candidates = new LinkedHashSet&lt;>(configCandidates);\n   Set&lt;ConfigurationClass> alreadyParsed = new HashSet&lt;>(configCandidates.size());\n   do &#123;\n       //注意：这里的parser是一个 ConfigurationClassParser 即对加了 @Configuration 的类的解析器.\n       //这里的 candidates是 configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));中读取的被@Configuration 注解的类\n       //parser是一个  org.springframework.context.annotation.ConfigurationClassParser 的对象\n       //调用 ontext.annotation.ConfigurationClassParser.doProcessConfigurationClass() 法处理ConfigurationClass\n      parser.parse(candidates);\n      parser.validate();\n\n      Set&lt;ConfigurationClass> configClasses = new LinkedHashSet&lt;>(parser.getConfigurationClasses());\n      configClasses.removeAll(alreadyParsed);\n\n      // Read the model and create bean definitions based on its content\n      if (this.reader == null) &#123;\n         this.reader = new ConfigurationClassBeanDefinitionReader(\n               registry, this.sourceExtractor, this.resourceLoader, this.environment,\n               this.importBeanNameGenerator, parser.getImportRegistry());\n      &#125;\n      this.reader.loadBeanDefinitions(configClasses);\n      alreadyParsed.addAll(configClasses);\n\n      candidates.clear();\n      if (registry.getBeanDefinitionCount() > candidateNames.length) &#123;\n         String[] newCandidateNames = registry.getBeanDefinitionNames();\n         Set&lt;String> oldCandidateNames = new HashSet&lt;>(Arrays.asList(candidateNames));\n         Set&lt;String> alreadyParsedClasses = new HashSet&lt;>();\n         for (ConfigurationClass configurationClass : alreadyParsed) &#123;\n            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n         &#125;\n         for (String candidateName : newCandidateNames) &#123;\n            if (!oldCandidateNames.contains(candidateName)) &#123;\n               BeanDefinition bd = registry.getBeanDefinition(candidateName);\n               if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp;\n                     !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;\n                  candidates.add(new BeanDefinitionHolder(bd, candidateName));\n               &#125;\n            &#125;\n         &#125;\n         candidateNames = newCandidateNames;\n      &#125;\n   &#125;\n   while (!candidates.isEmpty());\n\n   // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n   if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;\n      sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n   &#125;\n\n   if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123;\n      // Clear cache in externally provided MetadataReaderFactory; this is a no-op\n      // for a shared cache since it'll be cleared by the ApplicationContext.\n      ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n   &#125;\n&#125;\n\nConfigurationClassParser 类从源码中的*167行  -&gt;  199行  -&gt;  242行***按类层次结构追踪  处理 ConfigurationClass\nif (bd instanceof AnnotatedBeanDefinition) &#123;\n   parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());\n&#125;\n\nprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException &#123;\n   processConfigurationClass(new ConfigurationClass(metadata, beanName));\n&#125;\n\ndo &#123;\n   sourceClass = doProcessConfigurationClass(configClass, sourceClass);\n&#125;\n\ndoProcessConfigurationClass() 方法@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n      throws IOException &#123;\n\n   if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;\n      // Recursively process any member (nested) classes first\n      processMemberClasses(configClass, sourceClass);\n   &#125;\n\n   // Process any @PropertySource annotations\n    //处理了@PropertySource\n   for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), PropertySources.class,\n         org.springframework.context.annotation.PropertySource.class)) &#123;\n      if (this.environment instanceof ConfigurableEnvironment) &#123;\n         processPropertySource(propertySource);\n      &#125;\n      else &#123;\n         logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n               \"]. Reason: Environment must implement ConfigurableEnvironment\");\n      &#125;\n   &#125;\n\n   // Process any @ComponentScan annotations\n    //处理了@ComponentScan\n   Set&lt;AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n         sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n   if (!componentScans.isEmpty() &amp;&amp;\n         !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;\n      for (AnnotationAttributes componentScan : componentScans) &#123;\n         // The config class is annotated with @ComponentScan -> perform the scan immediately\n         Set&lt;BeanDefinitionHolder> scannedBeanDefinitions =\n               this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         // Check the set of scanned definitions for any further config classes and parse recursively if needed\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;\n            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n            if (bdCand == null) &#123;\n               bdCand = holder.getBeanDefinition();\n            &#125;\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;\n               parse(bdCand.getBeanClassName(), holder.getBeanName());\n            &#125;\n         &#125;\n      &#125;\n   &#125;\n\n   // Process any @Import annotations\n    //处理了@Import 与 springboot中的 @Import(AutoConfigurationImportSelector.class) 相关  \n   processImports(configClass, sourceClass, getImports(sourceClass), true);\n\n   // Process any @ImportResource annotations\n    //处理了@ImportResource\n   AnnotationAttributes importResource =\n         AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n   if (importResource != null) &#123;\n      String[] resources = importResource.getStringArray(\"locations\");\n      Class&lt;? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n      for (String resource : resources) &#123;\n         String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n         configClass.addImportedResource(resolvedResource, readerClass);\n      &#125;\n   &#125;\n\n   // Process individual @Bean methods\n    //处理了@Bean\n   Set&lt;MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n   for (MethodMetadata methodMetadata : beanMethods) &#123;\n      configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n   &#125;\n\n   // Process default methods on interfaces\n   processInterfaces(configClass, sourceClass);\n\n   // Process superclass, if any\n   if (sourceClass.getMetadata().hasSuperClass()) &#123;\n      String superclass = sourceClass.getMetadata().getSuperClassName();\n      if (superclass != null &amp;&amp; !superclass.startsWith(\"java\") &amp;&amp;\n            !this.knownSuperclasses.containsKey(superclass)) &#123;\n         this.knownSuperclasses.put(superclass, configClass);\n         // Superclass found, return its annotation metadata and recurse\n         return sourceClass.getSuperClass();\n      &#125;\n   &#125;\n\n   // No superclass -> processing is complete\n   return null;\n&#125;\n\nprocessImports() 方法private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,\n\t\t\tCollection&lt;SourceClass> importCandidates, boolean checkForCircularImports) &#123;\n\t//遍历每个 @Import 标签，生成被注入的 ImportSelector 子类的实例\n\t\tif (importCandidates.isEmpty()) &#123;\n\t\t\treturn;\n\t\t&#125;\n\n\t\tif (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;\n\t\t\tthis.problemReporter.error(new CircularImportProblem(configClass, this.importStack));\n\t\t&#125;\n\t\telse &#123;\n\t\t\tthis.importStack.push(configClass);\n\t\t\ttry &#123;\n\t\t\t\tfor (SourceClass candidate : importCandidates) &#123;\n\t\t\t\t\tif (candidate.isAssignable(ImportSelector.class)) &#123;\n\t\t\t\t\t\t// Candidate class is an ImportSelector -> delegate to it to determine imports\n\t\t\t\t\t\tClass&lt;?> candidateClass = candidate.loadClass();\n                                             \n\t\t\t\t\t\tImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);\n\t\t\t\t\t\tParserStrategyUtils.invokeAwareMethods(\n\t\t\t\t\t\t\t\tselector, this.environment, this.resourceLoader, this.registry);\n\t\t\t\t\t\tif (selector instanceof DeferredImportSelector) &#123;\n                            //对于DefferedImportSelector，只加入deferredImportSelectors列表中\n\t\t\t\t\t\t\tthis.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse &#123;\n// 对于普通ImportSelector，调用其selectImport()方法，筛掉exclude的，再嵌套processImports()，对需要被@Import的类的@Import注解进行处理\n\t\t\t\t\t\t\tString[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());//这里调用的就是 springboot中提到的注解了\n\t\t\t\t\t\t\tCollection&lt;SourceClass> importSourceClasses = asSourceClasses(importClassNames);\n\t\t\t\t\t\t\tprocessImports(configClass, currentSourceClass, importSourceClasses, false);\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;\n\t\t\t\t\t\t// Candidate class is an ImportBeanDefinitionRegistrar ->\n\t\t\t\t\t\t// delegate to it to register additional bean definitions\n\t\t\t\t\t\tClass&lt;?> candidateClass = candidate.loadClass();\n\t\t\t\t\t\tImportBeanDefinitionRegistrar registrar =\n\t\t\t\t\t\t\t\tBeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);\n\t\t\t\t\t\tParserStrategyUtils.invokeAwareMethods(\n\t\t\t\t\t\t\t\tregistrar, this.environment, this.resourceLoader, this.registry);\n\t\t\t\t\t\tconfigClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());\n\t\t\t\t\t&#125;\n\t\t\t\t\telse &#123;\n\t\t\t\t\t\t// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->\n\t\t\t\t\t\t// process it as an @Configuration class\n\t\t\t\t\t\tthis.importStack.registerImport(\n\t\t\t\t\t\t\t\tcurrentSourceClass.getMetadata(), candidate.getMetadata().getClassName());\n\t\t\t\t\t\tprocessConfigurationClass(candidate.asConfigClass(configClass));\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tcatch (BeanDefinitionStoreException ex) &#123;\n\t\t\t\tthrow ex;\n\t\t\t&#125;\n\t\t\tcatch (Throwable ex) &#123;\n\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\"Failed to process import candidates for configuration class [\" +\n\t\t\t\t\t\tconfigClass.getMetadata().getClassName() + \"]\", ex);\n\t\t\t&#125;\n\t\t\tfinally &#123;\n\t\t\t\tthis.importStack.pop();\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;","slug":"SpringBoot启动源码阅读","date":"2020-10-17T11:48:49.000Z","categories_index":"Java,SpringBoot","tags_index":"SpringBoot","author_index":"SongX_"},{"id":"ea20621308e6edf9176ae924fc5a127a","title":"Html导入自定义字体文件方法","content":"&emsp;&emsp;有关于编写 Html 静态页面时如何导入自定义字体文件以更换默认字体的方法，字体文件请自行寻找，字体转换工具请自行寻找。\n\n\n\n\n\n\n重点\n&emsp;&emsp;在开发时请务必注意区分使用的字体是否可进行商用\n\n\n一、准备文件&emsp;&emsp;首先我们需要准备到字体文件如下：\n\n&emsp;&emsp;如何获得以上文件请自行查找，网上下载的字体文件大都是 .tff 格式的文件，我们可以查找并使用字体转换工具对其进行转换成其他格式\n二、建立字体CSS文件&emsp;&emsp;在我们需要导入字体的 html 的 css 文件中，创建名为 font 的文件夹，将以上文件复制进文件夹，退回到上一级 css 中，创建 css 文件 ：fontset.css\n&emsp;&emsp;在文件中输入以下代码\n@font-face &#123;font-family: \"字体名称\";\n    src: url('font/字体文件.eot'); /* IE9*/\n    src: url('font/字体文件.eot') format('embedded-opentype'), /* IE6-IE8 */\n    url('font/字体文件.woff') format('woff'),\n    url('font/字体文件.ttf') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n    url('font/字体文件.svg') format('svg'); /* iOS 4.1- */\n  &#125;\n\n\n&emsp;接着在 Html 头部引用 fontset.css文件\n&lt;link rel=\"stylesheet\" href=\"css/fontset.css\" />\n\n&emsp;&emsp;之后我们便可以在 Html 中的 style 标签中使用font-family: &quot;字体名称&quot;引入自定义字体了\n&emsp;&emsp;如果我们想要在 Html 中直接默认使用我们导入的字体文件，我们可以在 fontset.css 中的 @front-face 下方加入如下代码设置全局字体为我们定义的字体文件。\n* &#123;\n    font-family:\"字体名称\";\n  &#125;\n\n&emsp;&emsp;如果我们想要在一个静态页面采用多个字体文件，我们可以在上一个 @front-face 中加入其它的 @front-face 模块，改变字体路径和字体名称即可\n","slug":"Html导入自定义字体文件","date":"2020-08-13T02:15:31.000Z","categories_index":"Html,前端","tags_index":"Html","author_index":"SongX_"}]